---
date: 2026-01-03T14:13:52+0000
researcher: dacloutier
git_commit: c6232e4ea681c8f547e52b809c2ae8a6cf77b7f8
branch: main
repository: nosrecettes.ca
topic: "Offline Cache Eviction Analysis - Current Implementation and Data Persistence"
tags: [research, codebase, pwa, offline, cache-eviction, workbox, service-worker, data-persistence, browser-storage]
status: complete
last_updated: 2026-01-03
last_updated_by: dacloutier
---

# Research: Offline Cache Eviction Analysis - Current Implementation and Data Persistence

**Date**: 2026-01-03T14:13:52+0000
**Researcher**: dacloutier
**Git Commit**: c6232e4ea681c8f547e52b809c2ae8a6cf77b7f8
**Branch**: main
**Repository**: nosrecettes.ca

## Research Question

The current offline access solution can still lead to data being evicted, in which case the app won't load. How is caching currently implemented, and what are the mechanisms that could lead to cache eviction?

## Summary

The nosrecettes.ca application **currently has a service worker implementation** using `vite-plugin-pwa` with Workbox. The implementation uses a **precaching strategy** for static assets (all recipes bundled in a ~7MB JavaScript file), but **lacks explicit cache persistence controls**. This means the browser can evict the cache under storage pressure, which would prevent the app from loading offline.

**Current State**:
- ✅ Service worker registered with `autoUpdate` strategy
- ✅ Precaches all static assets (JS, CSS, HTML, fonts, icons)
- ✅ 7MB cache size limit to accommodate large recipe bundle
- ✅ `navigateFallback` serves `/index.html` for all routes offline
- ❌ No explicit cache persistence (no `navigator.storage.persist()`)
- ❌ No IndexedDB for permanent data storage
- ❌ Relies on browser's eviction policies (can be cleared under storage pressure)
- ❌ Cloudinary images use `NetworkOnly` strategy (no offline caching)

**Key Risk**: Under storage pressure, browsers can evict service worker caches without warning, causing the app to fail loading offline.

## Detailed Findings

### Current Service Worker Configuration

**Location**: [vite.config.ts:16-38](vite.config.ts#L16-L38)

The application uses `vite-plugin-pwa` with the following Workbox configuration:

```typescript
VitePWA({
  registerType: 'autoUpdate',
  includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'mask-icon.svg'],
  manifest: false, // Use existing manifest.json generated by build:seo
  workbox: {
    globPatterns: ['**/*.{js,css,html,ico,png,svg,woff,woff2}'],
    maximumFileSizeToCacheInBytes: 7 * 1024 * 1024, // 7MB - accommodate large bundle with all recipes
    // Serve all routes from cache when offline (including admin routes)
    // React components will handle showing OfflineFallback for admin pages
    navigateFallback: '/index.html',
    runtimeCaching: [
      {
        // Cloudinary images - NetworkOnly (no caching)
        urlPattern: /^https:\/\/res\.cloudinary\.com\/.*/,
        handler: 'NetworkOnly',
      },
    ],
  },
  devOptions: {
    enabled: true, // Enable in dev mode for testing
    type: 'module',
  },
})
```

**Key characteristics**:
- **Precaching strategy**: All static assets cached at service worker installation
- **Cache size limit**: 7MB maximum file size (total cache can exceed this)
- **No explicit cache persistence**: Relies on browser defaults
- **Auto-update**: Service worker updates automatically when new version detected
- **Images**: Cloudinary images are NOT cached offline (NetworkOnly strategy)

---

### Service Worker Registration

**Location**: [src/hooks/usePwaUpdate.ts:1-38](src/hooks/usePwaUpdate.ts#L1-L38)

```typescript
export function usePwaUpdate() {
  const {
    offlineReady: [offlineReady],
    needRefresh: [needRefresh],
    updateServiceWorker,
  } = useRegisterSW({
    onRegistered(r) {
      console.log('Service Worker registered:', r)
    },
    onRegisterError(error) {
      console.error('Service Worker registration error:', error)
    },
  })

  const [showUpdateBanner, setShowUpdateBanner] = useState(false)

  useEffect(() => {
    if (needRefresh) {
      setShowUpdateBanner(true)
      // Auto-update is enabled, so the page will reload automatically
      // The banner just shows "updating..." status
      updateServiceWorker(true) // true = reload page after update
    }
  }, [needRefresh, updateServiceWorker])

  const dismissBanner = () => {
    setShowUpdateBanner(false)
  }

  return {
    showUpdateBanner,
    offlineReady,
    dismissBanner,
  }
}
```

**Key characteristics**:
- Uses `useRegisterSW` from `virtual:pwa-register/react` (provided by vite-plugin-pwa)
- Automatically updates service worker when new version detected
- Shows update banner during transition
- Reloads page after update completes

**App-level integration**: [src/App.tsx:9-13](src/App.tsx#L9-L13)

```typescript
const { showUpdateBanner, dismissBanner } = usePwaUpdate()

return (
  <HelmetProvider>
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <Toaster />
        <Sonner />
        {showUpdateBanner && <UpdateBanner onDismiss={dismissBanner} />}
        {/* ... routes ... */}
      </TooltipProvider>
    </QueryClientProvider>
  </HelmetProvider>
)
```

---

### Workbox Caching Strategy Details

**Precaching (Cache-First Strategy)**:
- All files matching `globPatterns` are cached at service worker installation
- Cached assets: JavaScript bundles, CSS files, HTML, icons, SVG, web fonts
- Files are versioned using content hashes (e.g., `index-DbeAWzEa.js`)
- Service worker maintains a precache manifest with file hashes
- On service worker update, old cache is deleted and new cache installed

**Runtime Caching**:
- **Cloudinary images**: `NetworkOnly` handler
  - Pattern: `/^https:\/\/res\.cloudinary\.com\/.*/`
  - No offline caching (requires network)
  - Falls back to placeholder image in UI on network failure

**Navigation Fallback**:
- All navigation requests serve `/index.html` from cache
- Enables client-side routing to work offline
- Admin routes load from cache, but components check online status

---

### Cache Eviction Risks

**Current Vulnerabilities**:

1. **No Persistent Storage Request**
   - Application does not call `navigator.storage.persist()`
   - Cache is marked as "best effort" storage by browser
   - Can be evicted when device storage is low

2. **Browser Eviction Policies**
   - Chrome/Edge: Evict caches when disk space < 10% remaining
   - Firefox: Evict caches when disk space critical
   - Safari: Aggressive eviction (7 days unused, or immediately under pressure)
   - All browsers: Can clear caches via manual "Clear browsing data"

3. **Service Worker Cache API Limitations**
   - Caches are stored in browser's temporary storage quota
   - No guarantee of permanence
   - Can be cleared by browser without app notification
   - Total storage quota shared with other sites (typically 20-60% of available disk)

4. **Large Bundle Size**
   - 7MB precache (3.5MB gzipped JavaScript + assets)
   - Increases likelihood of eviction on low-storage devices
   - Single point of failure (if cache evicted, entire app breaks)

**What happens when cache is evicted**:
1. User opens app while offline
2. Browser attempts to load `/index.html` from network
3. Network request fails (offline)
4. Service worker cannot serve from cache (evicted)
5. Browser shows "No internet connection" error
6. App does not load at all

---

### Data Persistence Mechanisms

**Current Storage Usage**:

1. **localStorage** (survives cache eviction)
   - GitHub configuration: `localStorage.getItem('github-config')`
   - Cloudinary configuration: `localStorage.getItem('cloudinary-config')`
   - Image cleanup queue: `localStorage.getItem('cloudinary-cleanup-queue')`
   - Used in: [src/pages/Index.tsx:46](src/pages/Index.tsx#L46), [src/pages/EditRecipe.tsx:98](src/pages/EditRecipe.tsx#L98), [src/utils/cloudinaryUtils.ts:110](src/utils/cloudinaryUtils.ts#L110)

2. **Service Worker Cache API** (can be evicted)
   - All static assets (HTML, JS, CSS, fonts, icons)
   - Managed by Workbox
   - No explicit persistence request

3. **No IndexedDB usage**
   - Searched codebase: no IndexedDB implementation found
   - Could be used for more permanent recipe storage

4. **No sessionStorage usage**
   - Cleared when tab/browser closes
   - Not used in application

**Storage Persistence API Availability**:
- `navigator.storage.persist()` - Request persistent storage (not currently used)
- `navigator.storage.estimate()` - Check storage quota and usage (not currently used)
- `navigator.storage.persisted()` - Check if storage is already persistent (not currently used)

---

### Recipe Data Architecture

**Current Implementation**: All recipes bundled at build time

**Location**: [src/recipes/index.ts:6-32](src/recipes/index.ts#L6-L32)

```typescript
// Dynamic import of all recipe files
const recipeModules = import.meta.glob('./*.ts', { eager: true })

export const recipes: Recipe[] = []

// Process all imported modules
Object.entries(recipeModules).forEach(([path, module]) => {
  if (path === './index.ts') return

  const moduleExports = module as Record<string, unknown>

  Object.values(moduleExports).forEach((exportedValue) => {
    if (
      exportedValue &&
      typeof exportedValue === 'object' &&
      'id' in exportedValue &&
      'title' in exportedValue
    ) {
      recipes.push(exportedValue as Recipe)
    }
  })
})

recipes.sort((a, b) => a.title.localeCompare(b.title))
```

**Key characteristics**:
- 721 recipes compiled into JavaScript bundle via `import.meta.glob({ eager: true })`
- Total bundle size: 5.7MB minified (~3.5MB gzipped)
- All recipes available immediately in memory (no API calls)
- Recipe data tightly coupled to application code
- Cannot be updated independently of app deployment

**Build-time bundle generation**: [package.json:9](package.json#L9)

```json
"build": "NODE_ENV=production npm run build:seo && vite build"
```

**Individual recipe structure**: [src/recipes/ailes-de-poulet-a-la-mangue-epicee.ts:1-42](src/recipes/ailes-de-poulet-a-la-mangue-epicee.ts#L1-L42)

Each recipe is a TypeScript file exporting a typed object with ingredients, instructions, metadata, and Cloudinary image URLs.

---

### Offline Functionality Implementation

**Online Status Detection**: [src/hooks/useOnlineStatus.ts:1-52](src/hooks/useOnlineStatus.ts#L1-L52)

```typescript
export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine)

  useEffect(() => {
    const checkConnectivity = async () => {
      if (!navigator.onLine) {
        setIsOnline(false)
        return
      }

      try {
        // Verify connectivity by fetching manifest
        const response = await fetch('/manifest.json', {
          cache: 'no-store',
          method: 'HEAD',
        })
        setIsOnline(response.ok)
      } catch {
        setIsOnline(false)
      }
    }

    void checkConnectivity()

    // Poll every 5 seconds
    const interval = setInterval(() => {
      void checkConnectivity()
    }, 5000)

    // Listen to browser events
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      clearInterval(interval)
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  return isOnline
}
```

**Key characteristics**:
- Combines `navigator.onLine` with actual network verification
- Polls connectivity every 5 seconds
- Used to guard admin pages from offline access

**Offline Fallback UI**: [src/components/OfflineFallback.tsx:1-46](src/components/OfflineFallback.tsx#L1-L46)

Shows message: "Cette fonctionnalité nécessite une connexion Internet. Les recettes sont disponibles hors ligne, mais pas les outils d'administration."

**Admin pages protected by online check**:
- [src/pages/EditRecipe.tsx:41-53](src/pages/EditRecipe.tsx#L41-L53)
- [src/pages/NewRecipe.tsx:28-40](src/pages/NewRecipe.tsx#L28-L40)
- [src/pages/Admin.tsx:8-20](src/pages/Admin.tsx#L8-L20)
- [src/pages/ManageCategories.tsx:27-39](src/pages/ManageCategories.tsx#L27-L39)

All admin pages check `useOnlineStatus()` and render `<OfflineFallback />` when offline.

---

### Image Handling and Offline Behavior

**Cloudinary Images - NetworkOnly Strategy**:

The current Workbox configuration explicitly disables caching for Cloudinary images:

```typescript
runtimeCaching: [
  {
    urlPattern: /^https:\/\/res\.cloudinary\.com\/.*/,
    handler: 'NetworkOnly',
  },
]
```

**Why NetworkOnly?**:
- Prevents accumulating large image caches (149 recipes have images)
- Images would consume significant storage (800KB-1.2MB per recipe)
- Reduces cache eviction risk by keeping cache size smaller

**Fallback behavior**: [src/components/ResponsiveImage.tsx:38-52](src/components/ResponsiveImage.tsx#L38-L52)

```tsx
if (imageError || !imageSrc) {
  if (!showPlaceholder) return null

  return (
    <div className="bg-muted flex items-center justify-center border-2 border-dashed">
      <div className="flex flex-col items-center justify-center text-muted-foreground p-4">
        <Utensils className="w-12 h-12 mb-2" />
        <span className="text-sm font-medium">Pas d'image</span>
      </div>
    </div>
  )
}
```

**Key characteristics**:
- Images fail gracefully when offline
- Shows "Pas d'image" placeholder with utensils icon
- No special offline messaging (treats missing images same as network failure)
- 79.3% of recipes (572) have no images, so most recipes work fully offline

---

### Cache Invalidation and Updates

**Automatic Cache Invalidation**:

When a new version is deployed:
1. Vite generates new bundle with different content hash (e.g., `index-NewHash.js`)
2. `vite-plugin-pwa` generates new service worker with updated precache manifest
3. Browser detects new service worker and installs it in background
4. Old cache is deleted on service worker activation
5. User sees update banner and can refresh to load new version

**Workbox default activation handler** (auto-generated):

```javascript
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name.startsWith('workbox-precache-') && name !== CURRENT_CACHE)
          .map((name) => caches.delete(name))
      )
    })
  )
})
```

**Update flow**:
1. Deploy new version to production
2. User visits site (service worker checks for update)
3. New service worker installs in background
4. [UpdateBanner.tsx](src/components/UpdateBanner.tsx) shows "Mise à jour en cours..."
5. Page auto-reloads with new version
6. Old cache cleaned up

---

### Storage Quota and Browser Limits

**Browser Storage Quotas** (approximate, varies by device):

- **Chrome/Edge**: 60% of available disk space (shared across all sites)
- **Firefox**: 50% of available disk space (shared across all sites)
- **Safari**: 1GB limit per origin (may be lower on iOS)

**Eviction Policies**:

1. **Chrome/Edge**:
   - Uses LRU (Least Recently Used) across all origins
   - Evicts when total storage exceeds quota
   - Persistent storage (via `persist()`) exempt from eviction

2. **Firefox**:
   - Groups data by origin
   - Evicts entire origins when quota exceeded
   - Persistent storage protected

3. **Safari**:
   - Aggressive eviction after 7 days of no site visit
   - Can evict immediately under storage pressure
   - iOS even more aggressive (caps at ~50MB per origin in some cases)

**Current app storage**:
- Precache: ~7MB (all static assets)
- localStorage: <1MB (GitHub config, Cloudinary config, cleanup queue)
- Total: ~7-8MB per user

**Risk analysis**:
- Medium risk on Android/desktop (reasonable quota, persistent storage available)
- High risk on iOS Safari (aggressive eviction, low quotas)
- Critical issue: App completely fails if cache evicted (no degraded mode)

---

## Code References

### Service Worker Configuration
- [vite.config.ts:16-38](vite.config.ts#L16-L38) - VitePWA and Workbox configuration
- [src/hooks/usePwaUpdate.ts:1-38](src/hooks/usePwaUpdate.ts#L1-L38) - Service worker registration hook
- [src/components/UpdateBanner.tsx:1-38](src/components/UpdateBanner.tsx#L1-L38) - Update notification UI
- [src/App.tsx:9-13](src/App.tsx#L9-L13) - App-level PWA integration

### Recipe Data Bundling
- [src/recipes/index.ts:6-32](src/recipes/index.ts#L6-L32) - Recipe aggregation via import.meta.glob
- [src/data/recipes.ts:1-7](src/data/recipes.ts#L1-L7) - Recipe data re-export
- [src/types/recipe.ts:1-53](src/types/recipe.ts#L1-L53) - Recipe TypeScript interface

### Offline Functionality
- [src/hooks/useOnlineStatus.ts:1-52](src/hooks/useOnlineStatus.ts#L1-L52) - Online/offline detection
- [src/components/OfflineFallback.tsx:1-46](src/components/OfflineFallback.tsx#L1-L46) - Offline message UI
- [src/pages/EditRecipe.tsx:41-53](src/pages/EditRecipe.tsx#L41-L53) - Admin page offline guard
- [src/components/ResponsiveImage.tsx:38-52](src/components/ResponsiveImage.tsx#L38-L52) - Image fallback

### Storage Usage
- [src/utils/cloudinaryUtils.ts:110-149](src/utils/cloudinaryUtils.ts#L110-149) - localStorage for image cleanup queue
- [src/pages/Index.tsx:46](src/pages/Index.tsx#L46) - localStorage for GitHub config check
- [src/pages/EditRecipe.tsx:98-103](src/pages/EditRecipe.tsx#L98-L103) - localStorage for loading GitHub config

---

## Architecture Documentation

### Current Offline Architecture

```
┌─────────────────────────────────────────────┐
│ Browser Storage Layers                      │
├─────────────────────────────────────────────┤
│                                             │
│  localStorage (Persistent)                  │
│  ├─ github-config                          │
│  ├─ cloudinary-config                      │
│  └─ cloudinary-cleanup-queue               │
│                                             │
│  Service Worker Cache (Can be evicted)     │
│  ├─ Precache (CacheFirst)                  │
│  │   ├─ index.html                         │
│  │   ├─ index-[hash].js (5.7MB)           │
│  │   ├─ index-[hash].css (70KB)           │
│  │   ├─ Icons, fonts                       │
│  │   └─ manifest.json                      │
│  │                                          │
│  └─ Runtime Cache                           │
│      └─ Cloudinary images (NetworkOnly)    │
│          └─ No offline caching              │
│                                             │
│  No IndexedDB                               │
│                                             │
└─────────────────────────────────────────────┘

Data Flow:
1. First visit: Download 3.5MB gzipped bundle
2. Service worker caches all static assets
3. localStorage stores admin credentials
4. Subsequent visits: Load from cache (offline capable)
5. Recipe data embedded in JavaScript (no separate API)

Failure Mode:
❌ Browser evicts service worker cache
   → App cannot load offline (no fallback)
   → localStorage survives (credentials preserved)
   → User must reconnect to re-cache app
```

### Cache Eviction Scenarios

**Scenario 1: Low Storage on Android**
1. User installs many apps, fills device storage
2. Android system storage < 10% remaining
3. Chrome evicts oldest caches (including nosrecettes.ca)
4. User opens app while offline → Network error

**Scenario 2: Safari 7-Day Eviction**
1. User installs app on iOS
2. User doesn't visit app for 7 days
3. Safari evicts all nosrecettes.ca caches
4. User opens app while offline → Network error

**Scenario 3: Manual Cache Clear**
1. User goes to Settings → Clear browsing data
2. Selects "Cached images and files"
3. Service worker cache deleted
4. User opens app while offline → Network error

**Scenario 4: Storage Pressure Eviction**
1. Browser running low on disk space
2. Browser automatically evicts caches from least-used sites
3. nosrecettes.ca cache evicted without notification
4. User opens app while offline → Network error

---

## Historical Context (from thoughts/)

**Previous Research**: [thoughts/shared/research/2025-12-28-offline-pwa-capabilities.md](thoughts/shared/research/2025-12-28-offline-pwa-capabilities.md)

This document (December 2025) analyzed the codebase when there was **no service worker implementation**. It recommended implementing Workbox with `vite-plugin-pwa`, which has since been implemented.

**Key findings from previous research**:
- Identified that all 721 recipes were already bundled (3.5MB gzipped)
- Recommended Workbox CacheFirst strategy for app shell
- Suggested NetworkFirst for Cloudinary images (with 50 image cache)
- Noted bundle size as potential performance concern
- Proposed update strategy with user prompts

**What has been implemented since**:
- ✅ `vite-plugin-pwa` installed (version 1.2.0)
- ✅ Service worker with Workbox precaching
- ✅ Auto-update strategy with update banner
- ✅ 7MB cache size limit for large bundle
- ✅ `navigateFallback` for client-side routing
- ❌ Cloudinary images changed to `NetworkOnly` (not NetworkFirst as recommended)
- ❌ No cache persistence request implemented

**Evolution of implementation**:
1. December 2025: No service worker
2. December 2025-January 2026: Implemented basic Workbox precaching
3. **Current state (January 2026)**: Working service worker, but vulnerable to eviction

---

## Related Research

- [thoughts/shared/research/2025-12-28-offline-pwa-capabilities.md](thoughts/shared/research/2025-12-28-offline-pwa-capabilities.md) - Original PWA research (pre-service worker implementation)
- [thoughts/shared/research/2025-12-29-pwa-installation-android.md](thoughts/shared/research/2025-12-29-pwa-installation-android.md) - PWA installation on Android
- [thoughts/shared/plans/2025-12-28-offline-pwa-capabilities.md](thoughts/shared/plans/2025-12-28-offline-pwa-capabilities.md) - Implementation plan for offline PWA

---

## Open Questions

1. **Storage Persistence**: Should we request persistent storage via `navigator.storage.persist()`?
2. **IndexedDB for Recipes**: Should recipes be stored separately in IndexedDB (more eviction-resistant than Cache API)?
3. **Graceful Degradation**: Should we implement a degraded mode if cache is evicted (e.g., show recipe list from localStorage)?
4. **Cache Monitoring**: Should we monitor cache status and warn users before eviction?
5. **Image Caching Strategy**: Should we implement limited Cloudinary image caching (current NetworkOnly means no offline images)?
6. **Bundle Size**: Should we split the bundle to reduce cache footprint and eviction risk?
7. **Background Sync**: Should we implement background sync to re-download recipes if cache is evicted?
8. **Storage Quota UI**: Should we show users their storage usage and allow manual cache management?
