# Offline PWA Capabilities Implementation Plan

## Overview

Implement service worker-based offline functionality for nosrecettes.ca to enable users to browse all 721 recipes without network connectivity. The app already bundles all recipe data (3.5MB gzipped) and has a PWA manifest - we're adding the missing service worker layer to cache the app shell and enable offline access.

## Current State Analysis

### What Exists:

- PWA manifest at [public/manifest.json](public/manifest.json) with proper configuration
- All 721 recipes bundled at build time via `import.meta.glob` in [src/recipes/index.ts:6-27](src/recipes/index.ts#L6-L27)
- Client-side routing with React Router v6 in [src/App.tsx](src/App.tsx)
- Image placeholder system in [src/components/ResponsiveImage.tsx:38-52](src/components/ResponsiveImage.tsx#L38-L52)
- Sonner toast notification system already integrated
- Vite build configuration at [vite.config.ts](vite.config.ts)
- Production bundle: 3.5MB gzipped (5.7MB minified)

### What's Missing:

- Service worker registration
- Cache strategy for app shell (HTML, CSS, JS)
- Update notification banner UI
- Runtime caching configuration

### Key Constraints:

- **Public pages only**: Admin routes (`/admin`, `/new-recipe`, `/edit-recipe/:slug`, `/manage-categories`) will NOT work offline
- **No image caching**: Images from Cloudinary will not be cached - show "Pas d'image" placeholder when offline
- **Auto-update**: New versions automatically applied in background, banner informs user of update happening
- **User-friendly notification**: Banner at top with clear message explaining the auto-update

## Desired End State

Users can:

1. Visit nosrecettes.ca once while online
2. Install as PWA on Android (already possible)
3. Browse all 721 recipes offline (new capability)
4. See placeholder images when offline (existing behavior leveraged)
5. Automatically receive new recipe updates without manual intervention

### Verification:

- Open nosrecettes.ca in browser
- Enable offline mode (DevTools → Network → Offline)
- Navigate to multiple recipe pages - all should load instantly
- Navigate to `/admin` - should show offline message
- Deploy new version, visit online - page automatically updates, banner briefly shows "Mise à jour en cours..."
- New recipes available immediately after update completes

## What We're NOT Doing

- ❌ Image caching (too much storage, images handled via placeholder)
- ❌ Admin page offline support (complex conflict resolution, out of scope)
- ❌ Background sync for edits (read-only offline mode)
- ❌ Bundle size optimization (separate effort, tracked separately)
- ❌ Offline analytics or metrics
- ❌ Install prompt customization (browser handles it)
- ❌ Partial recipe caching (all-or-nothing architecture already in place)

## Implementation Approach

Use `vite-plugin-pwa` with Workbox to generate and manage service worker automatically. This provides:

- Automatic cache versioning via file hashes
- Built-in cache invalidation on deployment
- TypeScript support
- Minimal runtime overhead (~10-20KB)

The service worker will use **CacheFirst** strategy for app shell (HTML, CSS, JS) and **NetworkOnly** for Cloudinary images (fail gracefully to existing placeholder).

Update flow:

1. New service worker installs in background when deployed
2. Banner appears: "Mise à jour en cours... Nouvelles recettes bientôt disponibles!"
3. Page automatically reloads when update completes
4. New cache activates, old cache deleted
5. New recipes available immediately

## Phase 1: Install and Configure vite-plugin-pwa

### Overview

Add the `vite-plugin-pwa` package and configure Workbox with cache strategies for app shell and images.

### Changes Required:

#### 1. Install Dependency

**Command**: `pnpm add -D vite-plugin-pwa`

#### 2. Update Vite Configuration

**File**: [vite.config.ts](vite.config.ts)
**Changes**: Add VitePWA plugin with Workbox configuration

```typescript
import { defineConfig } from 'vite'
import dyadComponentTagger from '@dyad-sh/react-vite-component-tagger'
import react from '@vitejs/plugin-react-swc'
import { VitePWA } from 'vite-plugin-pwa'
import path from 'path'

export default defineConfig(({ mode }) => ({
  base: '/',
  server: {
    host: '::',
    port: 8080,
  },
  plugins: [
    dyadComponentTagger(),
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'mask-icon.svg'],
      manifest: false, // Use existing manifest.json generated by build:seo
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff,woff2}'],
        // Only cache public routes, exclude admin pages
        navigateFallback: '/index.html',
        navigateFallbackDenylist: [
          /^\/admin/,
          /^\/new-recipe/,
          /^\/edit-recipe/,
          /^\/manage-categories/,
        ],
        runtimeCaching: [
          {
            // Cloudinary images - NetworkOnly (no caching)
            urlPattern: /^https:\/\/res\.cloudinary\.com\/.*/,
            handler: 'NetworkOnly',
          },
        ],
      },
      devOptions: {
        enabled: true, // Enable in dev mode for testing
        type: 'module',
      },
    }),
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: undefined,
      },
    },
  },
}))
```

**Key Configuration Decisions:**

- `registerType: 'autoUpdate'`: Automatically reload when new version available (no user action needed)
- `manifest: false`: Keep existing manifest.json generation from build:seo script
- `navigateFallbackDenylist`: Block admin routes from offline access
- `NetworkOnly` for images: Fail fast, show placeholder (no cache)
- `devOptions.enabled: true`: Test service worker in development

### Success Criteria:

#### Automated Verification:

- [x] `pnpm install` completes without errors
- [x] `pnpm run build` succeeds and generates service worker files in `dist/`
- [x] Verify `dist/sw.js` exists after build
- [x] Verify `dist/workbox-*.js` files exist after build
- [x] Type checking passes: `pnpm run build` (TypeScript compilation)
- [x] No build warnings related to PWA configuration

#### Manual Verification:

- [x] Run `pnpm run build && pnpm run preview`
- [x] Open browser DevTools → Application → Service Workers
- [x] Verify service worker is registered at `/sw.js`
- [x] Check Cache Storage - should see precached assets (HTML, CSS, JS)
- [x] Verify no console errors related to service worker

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation that the service worker is properly registered and caching assets before proceeding to Phase 2.

---

## Phase 2: Add Service Worker Registration and Update Notification

### Overview

Register the service worker in the app entry point and add hooks to detect when updates are happening (informational only - updates are automatic).

### Changes Required:

#### 1. Create Service Worker Registration Hook

**File**: `src/hooks/usePwaUpdate.ts` (new file)
**Changes**: Create custom hook to handle service worker lifecycle and show update status

```typescript
import { useEffect, useState } from 'react'
import { useRegisterSW } from 'virtual:pwa-register/react'

export function usePwaUpdate() {
  const {
    offlineReady: [offlineReady, setOfflineReady],
    needRefresh: [needRefresh, setNeedRefresh],
    updateServiceWorker,
  } = useRegisterSW({
    onRegistered(r) {
      console.log('Service Worker registered:', r)
    },
    onRegisterError(error) {
      console.error('Service Worker registration error:', error)
    },
  })

  const [showUpdateBanner, setShowUpdateBanner] = useState(false)

  useEffect(() => {
    if (needRefresh) {
      setShowUpdateBanner(true)
      // Auto-update is enabled, so the page will reload automatically
      // The banner just shows "updating..." status
      updateServiceWorker(true) // true = reload page after update
    }
  }, [needRefresh, updateServiceWorker])

  const dismissBanner = () => {
    setShowUpdateBanner(false)
  }

  return {
    showUpdateBanner,
    offlineReady,
    dismissBanner,
  }
}
```

#### 2. Update Main App Entry Point

**File**: [src/App.tsx](src/App.tsx)
**Changes**: Import and use the PWA update hook

```typescript
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { HelmetProvider } from 'react-helmet-async';
import { siteConfig } from '@/config/site.config';
import { UpdateBanner } from '@/components/UpdateBanner';
import { usePwaUpdate } from '@/hooks/usePwaUpdate';
import Index from "./pages/Index";
import RecipePage from "./pages/RecipePage";
import Admin from "./pages/Admin";
import NewRecipe from "./pages/NewRecipe";
import EditRecipe from "./pages/EditRecipe";
import ManageCategories from "./pages/ManageCategories";
import NotFound from "./pages/NotFound";

const queryClient = new QueryClient();

const basename = siteConfig.basePath;

const App = () => {
  const { showUpdateBanner, dismissBanner, offlineReady } = usePwaUpdate();

  return (
    <HelmetProvider>
      <QueryClientProvider client={queryClient}>
        <TooltipProvider>
          <Toaster />
          <Sonner />
          {showUpdateBanner && (
            <UpdateBanner onDismiss={dismissBanner} />
          )}
          <BrowserRouter basename={basename}>
            <Routes>
              <Route path="/" element={<Index />} />
              <Route path="/recipe/:slug" element={<RecipePage />} />
              <Route path="/admin" element={<Admin />} />
              <Route path="/new-recipe" element={<NewRecipe />} />
              <Route path="/edit-recipe/:slug" element={<EditRecipe />} />
              <Route path="/manage-categories" element={<ManageCategories />} />
              <Route path="*" element={<NotFound />} />
            </Routes>
          </BrowserRouter>
        </TooltipProvider>
      </QueryClientProvider>
    </HelmetProvider>
  );
};

export default App;
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `pnpm run build`
- [x] Build succeeds: `pnpm run build`
- [x] No TypeScript errors in `src/hooks/usePwaUpdate.ts`
- [x] No TypeScript errors in `src/App.tsx`

#### Manual Verification:

- [x] Run `pnpm run dev`
- [x] Open browser DevTools → Console
- [x] Verify "Service Worker registered" message appears
- [x] No service worker registration errors in console
- [x] Service worker shows as "activated" in DevTools → Application → Service Workers

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation that the service worker lifecycle hooks are working correctly before proceeding to Phase 3.

---

## Phase 3: Create Update Banner UI Component

### Overview

Build a user-friendly banner component that appears at the top of the page when an update is in progress. Since auto-update is enabled, this is purely informational - the page will reload automatically when the update completes.

### Changes Required:

#### 1. Create Update Banner Component

**File**: `src/components/UpdateBanner.tsx` (new file)
**Changes**: Create banner component showing update in progress

```typescript
import { X, RefreshCw } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface UpdateBannerProps {
  onDismiss: () => void;
}

export function UpdateBanner({ onDismiss }: UpdateBannerProps) {
  return (
    <div className="fixed top-0 left-0 right-0 z-50 bg-primary text-primary-foreground shadow-lg">
      <div className="container mx-auto px-4 py-3">
        <div className="flex items-center justify-between gap-4">
          <div className="flex items-center gap-3 flex-1">
            <RefreshCw className="h-5 w-5 flex-shrink-0 animate-spin" />
            <div className="flex-1">
              <p className="text-sm font-medium">
                Mise à jour en cours...
              </p>
              <p className="text-xs opacity-90 mt-1">
                Nouvelles recettes bientôt disponibles! La page se rafraîchira automatiquement.
              </p>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Button
              onClick={onDismiss}
              variant="ghost"
              size="sm"
              className="h-8 w-8 p-0"
              aria-label="Fermer"
            >
              <X className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

**Design Decisions:**

- **Fixed positioning**: Always visible at top, doesn't scroll away
- **Primary color background**: High visibility, matches brand
- **Spinning icon**: RefreshCw with animate-spin to show active update
- **Informational only**: No action button needed - update is automatic
- **Two-line message**: Status + what's happening next
- **Dismissible**: User can close banner (but update still happens)
- **z-index: 50**: Above most content but below modals
- **Clear expectations**: Explains page will refresh automatically

#### 2. Add Layout Padding for Banner (Optional Enhancement)

**File**: [src/pages/Index.tsx](src/pages/Index.tsx) (and other page components if needed)
**Changes**: Add top padding when banner is visible to prevent content overlap

```typescript
// Example implementation if banner covers content
// Add conditional className to main container:
<div className={cn("main-content", showUpdateBanner && "pt-20")}>
  {/* Page content */}
</div>
```

**Note**: This step is OPTIONAL. Only implement if testing reveals the banner covers important interactive elements. The fixed banner should overlay non-critical header space.

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `pnpm run build`
- [x] Build succeeds: `pnpm run build`
- [x] No TypeScript errors in `src/components/UpdateBanner.tsx`
- [x] Component uses existing shadcn/ui Button component correctly

#### Manual Verification:

- [x] Banner appears at top of page when update is detected
- [x] Banner displays "Mise à jour en cours..." with spinning RefreshCw icon
- [x] Second line explains automatic refresh clearly
- [x] "X" button dismisses banner (update still happens in background)
- [x] Page automatically reloads after a few seconds (update completes)
- [x] Banner is readable on mobile devices (responsive text/spacing)
- [x] Banner has sufficient color contrast for accessibility
- [x] Spinning icon animation is smooth (not janky)
- [x] Banner does not cover critical navigation or content

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation that the banner UI is user-friendly and the auto-update behavior works correctly before proceeding to Phase 4.

---

## Phase 4: Add Offline Route Handling

### Overview

Implement graceful handling for admin routes when accessed offline, showing a clear message that these features require internet connectivity.

### Changes Required:

#### 1. Create Offline Fallback Component

**File**: `src/components/OfflineFallback.tsx` (new file)
**Changes**: Create component to show when offline on restricted routes

```typescript
import { WifiOff } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useNavigate } from 'react-router-dom';

export function OfflineFallback() {
  const navigate = useNavigate();

  const handleGoHome = () => {
    navigate('/');
  };

  const handleRetry = () => {
    window.location.reload();
  };

  return (
    <div className="min-h-screen flex items-center justify-center p-4 bg-background">
      <div className="max-w-md w-full text-center space-y-6">
        <div className="flex justify-center">
          <div className="rounded-full bg-muted p-6">
            <WifiOff className="h-12 w-12 text-muted-foreground" />
          </div>
        </div>

        <div className="space-y-2">
          <h1 className="text-2xl font-bold text-foreground">
            Connexion requise
          </h1>
          <p className="text-muted-foreground">
            Cette fonctionnalité nécessite une connexion Internet.
            Les recettes sont disponibles hors ligne, mais pas les outils d'administration.
          </p>
        </div>

        <div className="flex flex-col sm:flex-row gap-3 justify-center">
          <Button onClick={handleRetry} variant="default">
            Réessayer
          </Button>
          <Button onClick={handleGoHome} variant="outline">
            Retour aux recettes
          </Button>
        </div>
      </div>
    </div>
  );
}
```

#### 2. Create Online Status Hook

**File**: `src/hooks/useOnlineStatus.ts` (new file)
**Changes**: Create hook to detect online/offline state

```typescript
import { useState, useEffect } from 'react'

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine)

  useEffect(() => {
    const handleOnline = () => setIsOnline(true)
    const handleOffline = () => setIsOnline(false)

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  return isOnline
}
```

#### 3. Update Admin Pages with Offline Guard

**File**: [src/pages/Admin.tsx](src/pages/Admin.tsx)
**Changes**: Add offline detection and show fallback

```typescript
import { useOnlineStatus } from '@/hooks/useOnlineStatus';
import { OfflineFallback } from '@/components/OfflineFallback';

const Admin = () => {
  const isOnline = useOnlineStatus();

  if (!isOnline) {
    return <OfflineFallback />;
  }

  // Existing admin page content
  return (
    // ... existing JSX
  );
};

export default Admin;
```

**Apply same pattern to:**

- [src/pages/NewRecipe.tsx](src/pages/NewRecipe.tsx)
- [src/pages/EditRecipe.tsx](src/pages/EditRecipe.tsx)
- [src/pages/ManageCategories.tsx](src/pages/ManageCategories.tsx)

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `pnpm run build`
- [x] Build succeeds: `pnpm run build`
- [x] No TypeScript errors in new components/hooks
- [x] Linting passes: `pnpm run lint` (no new errors from our changes)

#### Manual Verification:

**IMPORTANT**: These tests must be run with the production build using `pnpm run build && pnpm run preview`, NOT `pnpm run dev`. Dev mode doesn't fully support offline PWA features.

**Test Steps:**

1. [x] Run `pnpm run build && pnpm run preview`
2. [x] Navigate to home page while online - service worker registers
3. [x] Navigate to `/admin` while online - normal page loads
4. [x] Enable offline mode (DevTools → Network → Offline)
5. [x] Navigate to `/admin` while offline - OfflineFallback component displays ✅
6. [x] Verify "Réessayer" button attempts to reload
7. [x] Verify "Retour aux recettes" button navigates to home
8. [x] Test same behavior for `/new-recipe`, `/edit-recipe/[slug]`, `/manage-categories`
9. [x] Verify public recipe pages still work offline (/, /recipe/:slug)
10. [x] Go back online - admin pages should work normally again

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation that offline routing works correctly before proceeding to Phase 5.

---

## Phase 5: End-to-End Testing and Documentation

### Overview

Comprehensive testing of the full offline experience and documentation of the implementation.

### Changes Required:

#### 1. Update Research Document

**File**: [thoughts/shared/research/2025-12-28-offline-pwa-capabilities.md](thoughts/shared/research/2025-12-28-offline-pwa-capabilities.md)
**Changes**: Add implementation summary at the end

```markdown
---

## Implementation Summary [2025-12-28]

**Status**: ✅ Implemented

**Changes Made:**

1. Installed `vite-plugin-pwa` v0.20.5
2. Configured Workbox in [vite.config.ts](vite.config.ts) with CacheFirst for app shell
3. Created service worker registration hook at [src/hooks/usePwaUpdate.ts](src/hooks/usePwaUpdate.ts)
4. Added update banner component at [src/components/UpdateBanner.tsx](src/components/UpdateBanner.tsx)
5. Implemented offline fallback for admin routes at [src/components/OfflineFallback.tsx](src/components/OfflineFallback.tsx)
6. Added online status detection hook at [src/hooks/useOnlineStatus.ts](src/hooks/useOnlineStatus.ts)

**Resolved Questions:**

- ✅ Admin pages: Read-only offline mode (admin routes blocked)
- ✅ Image caching: No caching (NetworkOnly strategy, show placeholder)
- ✅ Update mechanism: Auto-update (page automatically reloads when new version ready)
- ✅ Update notification: Informational banner with spinning icon
- ✅ Service worker scope: Public pages only

**Performance Impact:**

- Service worker runtime: +15KB (~5KB gzipped)
- Initial cache storage: ~3.5MB (app shell)
- Update mechanism: Background installation, user-triggered activation

**Verification:**

- Offline browsing: All 721 recipes accessible without network
- Admin routes: Blocked offline with clear message
- Update flow: Banner appears, user clicks, page reloads with new content
- Cache invalidation: Old cache deleted on service worker activation
```

#### 2. Create README Section (Optional)

**File**: `README.md` (if it exists)
**Changes**: Add PWA/Offline section documenting the feature

````markdown
## PWA & Offline Support

Nosrecettes.ca is a Progressive Web App with full offline capabilities:

- **Install on Android**: Add to home screen for native app-like experience
- **Offline browsing**: All 721 recipes available without internet connection
- **Automatic updates**: Notification banner when new recipes are published
- **Image placeholders**: Graceful fallback when images unavailable offline

### For Developers

Service worker is generated by `vite-plugin-pwa` during build. Configuration in [vite.config.ts](vite.config.ts).

**Testing offline mode:**

```bash
pnpm run build
pnpm run preview
# Open DevTools → Network → Enable "Offline"
```
````

**Admin routes**: Intentionally blocked offline (require network connectivity)

````

#### 3. Add Package.json Script for PWA Testing
**File**: [package.json](package.json)
**Changes**: Add convenient script for testing PWA

```json
{
  "scripts": {
    "dev": "vite",
    "build": "NODE_ENV=production npm run build:seo && vite build",
    "build:dev": "npm run build:seo && vite build --mode development",
    "build:seo": "NODE_ENV=production node scripts/build-seo.js",
    "test:pwa": "npm run build && npm run preview",
    "generate:sitemap": "node scripts/generate-sitemap.js",
    // ... other scripts
  }
}
````

### Success Criteria:

#### Automated Verification:

- [ ] Build succeeds: `pnpm run build`
- [ ] Preview server starts: `pnpm run preview`
- [ ] No console errors when loading site
- [ ] Service worker registers successfully
- [ ] Cache storage populated with app assets

#### Manual Verification (Full End-to-End Test):

**Online Initial Load:**

1. [ ] Clear all site data (DevTools → Application → Clear storage)
2. [ ] Load https://nosrecettes.ca (or preview URL)
3. [ ] Verify service worker registers (DevTools → Application → Service Workers)
4. [ ] Verify cache populated (DevTools → Application → Cache Storage)
5. [ ] Navigate to 3-5 different recipes - all load normally
6. [ ] Verify images load from Cloudinary
7. [ ] No console errors

**Offline Browsing:** 8. [ ] Enable offline mode (DevTools → Network → Offline) 9. [ ] Refresh page - should load from cache 10. [ ] Navigate to home page - loads instantly 11. [ ] Navigate to 5-10 different recipes - all load instantly 12. [ ] Verify images show "Pas d'image" placeholder (existing behavior) 13. [ ] Search/filter recipes - all functionality works 14. [ ] Navigate to `/admin` - shows OfflineFallback component 15. [ ] Click "Retour aux recettes" - returns to home page

**Update Flow:** 16. [ ] Disable offline mode (back online) 17. [ ] Simulate new deployment: Unregister service worker, clear cache 18. [ ] Re-register service worker with modified version 19. [ ] Reload page - update banner should appear at top 20. [ ] Verify banner text: "Mise à jour en cours..." 21. [ ] Verify second line: "Nouvelles recettes bientôt disponibles! La page se rafraîchira automatiquement." 22. [ ] Verify RefreshCw icon is spinning (animate-spin class) 23. [ ] Wait a few seconds - page should automatically reload 24. [ ] Verify new service worker activated 25. [ ] Verify old cache deleted 26. [ ] Test dismissing banner: Click X - banner closes but update still proceeds

**Mobile/PWA Install (Android):** 27. [ ] Open site on Android device (Chrome) 28. [ ] Verify "Add to Home Screen" prompt appears 29. [ ] Install PWA to home screen 30. [ ] Open from home screen - launches in standalone mode 31. [ ] Test offline browsing from PWA install 32. [ ] Verify update banner appears in PWA mode 33. [ ] Verify auto-reload works in PWA mode

**Accessibility:** 34. [ ] Update banner readable at 200% zoom 35. [ ] Banner dismiss button keyboard accessible (Tab navigation) 36. [ ] OfflineFallback component screen reader friendly 37. [ ] Sufficient color contrast on update banner 38. [ ] Spinning icon doesn't trigger motion sensitivity (smooth animation)

**Implementation Note**: This is the final verification phase. All items must pass before considering the implementation complete.

---

## Testing Strategy

### Unit Tests

**Not Required**: This implementation is primarily configuration and UI components that integrate with browser APIs. Manual testing is more effective than unit tests for service worker behavior.

### Integration Tests

**Not Required**: Service worker lifecycle and cache behavior are best tested manually in browser DevTools due to their reliance on browser-specific implementations.

### Manual Testing Steps

See Phase 5 Success Criteria for comprehensive manual testing checklist covering:

- Initial load and cache population
- Offline browsing all routes
- Admin route blocking offline
- Update notification flow
- PWA installation on mobile
- Accessibility verification

### Performance Testing

**Recommended Manual Checks:**

1. **Initial Load Impact**: Compare load time before/after service worker (should be similar first visit)
2. **Subsequent Visits**: Verify instant load from cache (0 network requests)
3. **Cache Storage Size**: Verify ~3.5MB cache size (acceptable for recipe app)
4. **Update Performance**: Verify background installation doesn't block UI

**Tools:**

- Chrome DevTools Lighthouse (PWA audit)
- DevTools Network tab (cache hits vs misses)
- DevTools Application → Cache Storage (size verification)

## Performance Considerations

### Cache Storage Impact:

- **Initial cache**: 3.5MB (app shell: HTML, CSS, JS)
- **No image caching**: 0MB additional (images always network-only)
- **Total storage**: ~3.5MB (well within PWA limits)

### Network Performance:

- **First visit**: Same as current (3.5MB download)
- **Subsequent visits**: 0 network requests (instant load)
- **Update deployment**: Background download (non-blocking)

### Service Worker Overhead:

- **Runtime cost**: ~15KB additional JavaScript (~5KB gzipped)
- **Registration time**: <50ms on modern devices
- **Cache lookup**: <10ms per request

### User Experience Impact:

- **Positive**: Instant load on repeat visits, offline capability
- **Negative**: None (update banner is non-intrusive, dismissible)

## Migration Notes

### No Data Migration Required

This is a pure addition - no existing data or behavior changes.

### Deployment Considerations:

1. **First deployment**: Users won't see service worker until they visit post-deploy
2. **Cache invalidation**: Automatic via file hash versioning
3. **Rollback strategy**: Remove VitePWA plugin from vite.config.ts, rebuild, deploy
4. **User cache cleanup**: Automatic on service worker unregistration (if rolled back)

### Breaking Changes:

None. This is a progressive enhancement - browsers without service worker support will continue to work as before.

### Compatibility:

- **Service Workers**: Chrome 40+, Firefox 44+, Safari 11.1+, Edge 17+
- **PWA Install**: Chrome Android 31+, Safari iOS 11.3+
- **Cache API**: Chrome 40+, Firefox 39+, Safari 11.1+

Modern browser coverage: 97%+ of users (caniuse.com/serviceworkers)

## References

- Original research: [thoughts/shared/research/2025-12-28-offline-pwa-capabilities.md](thoughts/shared/research/2025-12-28-offline-pwa-capabilities.md)
- vite-plugin-pwa docs: https://vite-pwa-org.netlify.app/
- Workbox strategies: https://developer.chrome.com/docs/workbox/modules/workbox-strategies/
- Service Worker API: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
- PWA manifest spec: https://www.w3.org/TR/appmanifest/

## Risk Assessment

### Low Risk:

- ✅ Service worker is well-isolated (can't break existing functionality)
- ✅ Automatic fallback for unsupported browsers
- ✅ Easy rollback (remove plugin, rebuild)

### Medium Risk:

- ⚠️ Cache invalidation bugs (mitigated by Workbox automatic versioning)
- ⚠️ Update banner UX issues (mitigated by user testing in Phase 5)

### Mitigation Strategies:

1. **Cache versioning**: Workbox handles this automatically via file hashes
2. **Manual cache clear**: Users can clear in DevTools if issues arise
3. **Update skip**: Users can dismiss banner and update later
4. **Monitoring**: Log service worker registration errors to console for debugging

## Future Enhancements (Out of Scope)

1. **Limited image caching**: Cache 10-20 most viewed recipe images
2. **Install prompt customization**: Custom UI for "Add to Home Screen"
3. **Offline analytics**: Track which recipes viewed offline
4. **Background sync**: Queue admin edits made offline, sync when online
5. **Bundle optimization**: Code splitting to reduce initial download
6. **Push notifications**: Notify users when new recipes published
